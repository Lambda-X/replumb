<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>replumb.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Replumb</span> <span class="project-version">0.1.4-alpha1-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>replumb</span></div></div></li><li class="depth-2 current"><a href="replumb.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="replumb.core.html#var-browser-options"><div class="inner"><span>browser-options</span></div></a></li><li class="depth-1"><a href="replumb.core.html#var-error-.3Estr"><div class="inner"><span>error-&gt;str</span></div></a></li><li class="depth-1"><a href="replumb.core.html#var-get-prompt"><div class="inner"><span>get-prompt</span></div></a></li><li class="depth-1"><a href="replumb.core.html#var-nodejs-options"><div class="inner"><span>nodejs-options</span></div></a></li><li class="depth-1"><a href="replumb.core.html#var-read-eval-call"><div class="inner"><span>read-eval-call</span></div></a></li><li class="depth-1"><a href="replumb.core.html#var-result-.3Estring"><div class="inner"><span>result-&gt;string</span></div></a></li><li class="depth-1"><a href="replumb.core.html#var-success.3F"><div class="inner"><span>success?</span></div></a></li><li class="depth-1"><a href="replumb.core.html#var-unwrap-result"><div class="inner"><span>unwrap-result</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">replumb.core</h1><div class="doc"><div class="markdown"></div></div><div class="public anchor" id="var-browser-options"><h3>browser-options</h3><div class="usage"><code>(browser-options load-fn!)</code><code>(browser-options src-paths read-file-fn!)</code></div><div class="doc"><div class="markdown"><p>Creates the browser option map for read-eval-call.</p>
<p>The 1-arity function requires a <code>load-fn!</code> compatible with ClojureScript <code>cljs.js/*load-fn*</code>. Use it if you know what you are doing and follow this protocol:</p>
<pre><code>Each runtime environment provides a different way to load a library.
Whatever function `*load-fn*` is bound to will be passed two arguments
- a map and a callback function: The map will have the following keys:

    :name   - the name of the library (a symbol)
    :macros - modifier signaling a macros namespace load
    :path   - munged relative library path (a string)

The callback cb, upon resolution, will need to pass the same map:

    :lang       - the language, :clj or :js
    :source     - the source of the library (a string)
    :cache      - optional, if a :clj namespace has been precompiled to
                  :js, can give an analysis cache for faster loads.
    :source-map - optional, if a :clj namespace has been precompiled
                  to :js, can give a V3 source map JSON

If the resource could not be resolved, the callback should be invoked with
nil.
</code></pre>
<p>The 2-arity function accepts a sequence of source paths and <code>read-file-fn!</code>, an asynchronous 2-arity function with signature <code>[file-path src-cb]</code> where src-cb is itself a function <code>(fn [source]
...)</code> that needs to be called with the file content as string (<code>nil</code> if no file is found).</p></div></div></div><div class="public anchor" id="var-error-.3Estr"><h3>error-&gt;str</h3><div class="usage"><code>(error-&gt;str error)</code><code>(error-&gt;str error print-stack?)</code></div><div class="doc"><div class="markdown"><p>Return the message string of the input <code>js/Error</code>.</p></div></div></div><div class="public anchor" id="var-get-prompt"><h3>get-prompt</h3><div class="usage"><code>(get-prompt)</code></div><div class="doc"><div class="markdown"><p>Retrieves the REPL prompt to display, according to the current namespace. Returns a string.</p></div></div></div><div class="public anchor" id="var-nodejs-options"><h3>nodejs-options</h3><div class="usage"><code>(nodejs-options load-fn!)</code><code>(nodejs-options src-paths read-file-fn!)</code></div><div class="doc"><div class="markdown"><p>Creates the Node.js option map for read-eval-call.</p>
<p>The 1-arity function requires a <code>load-fn!</code> compatible with ClojureScript <code>cljs.js/*load-fn*</code>. Use it if you know what you are doing and follow this protocol:</p>
<pre><code>Each runtime environment provides a different way to load a library.
Whatever function `*load-fn*` is bound to will be passed two arguments
- a map and a callback function: The map will have the following keys:

    :name   - the name of the library (a symbol)
    :macros - modifier signaling a macros namespace load
    :path   - munged relative library path (a string)

The callback cb, upon resolution, will need to pass the same map:

    :lang       - the language, :clj or :js
    :source     - the source of the library (a string)
    :cache      - optional, if a :clj namespace has been precompiled to
                  :js, can give an analysis cache for faster loads.
    :source-map - optional, if a :clj namespace has been precompiled
                  to :js, can give a V3 source map JSON

If the resource could not be resolved, the callback should be invoked with
nil.
</code></pre>
<p>The 2-arity function accepts a sequence of source paths and <code>read-file-fn!</code>, an asynchronous 2-arity function with signature <code>[file-path src-cb]</code> where src-cb is itself a function <code>(fn [source]
...)</code> that needs to be called with the file content as string (<code>nil</code> if no file is found).</p></div></div></div><div class="public anchor" id="var-read-eval-call"><h3>read-eval-call</h3><div class="usage"><code>(read-eval-call callback source)</code><code>(read-eval-call opts callback source)</code></div><div class="doc"><div class="markdown"><p>Reads, evaluates and calls back with the evaluation result.</p>
<p>The first parameter is a map of configuration options, currently supporting:</p>
<ul>
  <li><code>:verbose</code> will enable the the evaluation logging, defaults to false</li>
  <li><code>:warning-as-error</code> will consider a compiler warning as error</li>
  <li><code>:target</code> <code>:nodejs</code> and <code>:browser</code> supported, the latter is used if missing</li>
  <li><code>:init-fn!</code> user provided initialization function, it will be passed a map:
    <pre><code>:form   ;; the form to evaluate, as data
:ns     ;; the current namespace, as symbol
:target ;; the current target
</code></pre>
  </li>
  <li>
    <p><code>:load-fn!</code> will override replumb&rsquo;s default <code>cljs.js/*load-fn*</code>. It rules out <code>:read-file-fn!</code>, losing any perk of using <code>replumb.load</code> helpers. Use it if you know what you are doing and follow this protocol:</p>
    <pre><code>Each runtime environment provides a different way to load a library.
Whatever function `*load-fn*` is bound to will be passed two arguments
- a map and a callback function: The map will have the following keys:

    :name   - the name of the library (a symbol)
    :macros - modifier signaling a macros namespace load
    :path   - munged relative library path (a string)

The callback cb, upon resolution, will need to pass the same map:

    :lang       - the language, :clj or :js
    :source     - the source of the library (a string)
    :cache      - optional, if a :clj namespace has been precompiled to
                  :js, can give an analysis cache for faster loads.
    :source-map - optional, if a :clj namespace has been precompiled
                  to :js, can give a V3 source map JSON

If the resource could not be resolved, the callback should be invoked with
nil.
</code></pre>
  </li>
  <li>
  <p><code>:read-file-fn!</code> an asynchronous 2-arity function with signature <code>[file-path src-cb]</code> where src-cb is itself a function <code>(fn [source]
...)</code> that needs to be called with the file content as string (<code>nil</code> if no file is found). It is mutually exclusive with <code>:load-fn!</code> and will be ignored in case both are present</p></li>
  <li>
  <p><code>:src-paths</code> a vector of paths containing source files</p></li>
</ul>
<p>The second parameter, <code>callback</code>, should be a 1-arity function which receives the result map, whose result keys will be:</p>
<pre><code>:success?  ;; a boolean indicating if everything went right
:value     ;; (if (success? result)) will contain the actual yield of the evaluation
:error     ;; (if (not (success? result)) will contain a js/Error
:warning   ;; in case a warning was thrown and :warning-as-error is falsey
:form      ;; the evaluated form as data structure (not a string)
</code></pre>
<p>The third parameter is the source string to be read and evaluated.</p>
<p>It initializes the repl harness either on first execution or if an option in <code>#{:src-paths :init-fn!}</code> changes from the previous <code>read-eval-call</code>.</p></div></div></div><div class="public anchor" id="var-result-.3Estring"><h3>result-&gt;string</h3><div class="usage"><code>(result-&gt;string result-map)</code><code>(result-&gt;string result-map print-stack?)</code><code>(result-&gt;string result-map print-stack? include-warning?)</code></div><div class="doc"><div class="markdown"><p>Given a <code>result-map</code>, returns the result of the evaluation as string.</p>
<ul>
  <li>When <code>include-warning?</code> is true, then the string yields from, in order, <code>:error</code>, then <code>:warning</code> and then eventually <code>:value</code>.</li>
  <li>When <code>print-stack?</code> is true, the error string will include the stack trace.</li>
</ul></div></div></div><div class="public anchor" id="var-success.3F"><h3>success?</h3><div class="usage"><code>(success? result-map)</code></div><div class="doc"><div class="markdown"><p>Given a <code>result-map</code>, tells whether the evaluation was successful.</p></div></div></div><div class="public anchor" id="var-unwrap-result"><h3>unwrap-result</h3><div class="usage"><code>(unwrap-result result-map)</code><code>(unwrap-result result-map include-warning?)</code></div><div class="doc"><div class="markdown"><p>Unwraps the result of an evaluation.</p>
<p>It returns the content of <code>:value</code> in case of success and the content of <code>:error</code> (a <code>js/Error</code>) in case of failure.</p>
<p>When <code>include-warning?</code> is true, then the value yields from, in order, <code>:error</code>, then <code>:warning</code> and then eventually <code>:value</code>.</p></div></div></div></div></body></html>